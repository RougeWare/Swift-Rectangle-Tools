//
//  Integer Size Extensions.swift
//  RectangleTools
//
//  Created by Ben Leggiero on 2019-12-04.
//  Copyright Â© 2019 Ben Leggiero BH-1-PS.
//

import Foundation



/// Allows you to treat an integer-size 2D object as a grid which scans from min-x/min-y to max-x/max-y in x scanlines.
///
/// - Attention: Indices outside the bounds of the grid are treated as its last element (max-x, max-y)
public protocol Collection2D: Collection
    where Index == Collection2DIndex<Length>
{
    associatedtype Length: BinaryInteger where Length.Stride: SignedInteger
    associatedtype Element = Index
    
    
    
    /// Returns the last index which addresses a real element.
    ///
    /// Any indices after this are not in this grid and thus should not be addressed.
    var lastValidIndex: Index { get }
    
    /// Returns the last element in this grid
    var lastValidElement: Element { get }
    
    
    /// Maps this grid to a 2D array of values, using the given transformer to generate them.
    ///
    /// This will scan the size from min-x/min-y to max-x/max-y in left-to-right horizontal scanlines.
    ///
    /// - Parameters:
    ///   - transformer: The function which will transform each element to the new value/type
    ///    - element: Each position in a scanline of this Size
    /// - Returns: A 2D array of values as generated by the given transformer
    /// - Throws: Anything the given transformer function throws
    func map2D<ElementOfResult>(_ transformer: (_ element: Element) throws -> ElementOfResult) rethrows -> [[ElementOfResult]]
}



@available(*, renamed: "Collection2D", message: "Size2DCollection was removed in 2.12, replaced by the more generic and powerful `Collection2D`. The behavior is the same, just usable on more types")
public typealias Size2DCollection = Collection2D & Size2D



/// This functions as a basic point index in a 2D collection.
///
/// - Note: Though We wanted this to be a `BinaryIntegerPoint`, it can't be because it strictly acts as a point in a scanline pattern, whereas a `BinaryIntegerPoint` can act as any point in an integer plane.
public struct Collection2DIndex<Length: BinaryInteger> {
    
    /// The position within a row of the scanline in a 2D collection
    public let x: Length
    
    /// The row of a scanline in a 2D collection
    public let y: Length
    
    
    /// Creates a new index for a 2D collection
    ///
    /// - Parameters:
    ///   - x: The position within a row of the scanline in a 2D collection
    ///   - y: The row of a scanline in a 2D collection
    public init(x: Length, y: Length) {
        self.x = x
        self.y = y
    }
}



extension Collection2DIndex: Comparable {
    public static func < (lhs: Collection2DIndex<Length>, rhs: Collection2DIndex<Length>) -> Bool {
        lhs.y == rhs.y
            ? lhs.x < rhs.x
            : lhs.y < rhs.y
    }
}



extension Collection2DIndex: Point2D {
}



public extension Collection2D 
    where Element == Index,
          Self: CartesianMeasurable
{
    
    var startIndex: Index { Index(x: minX, y: minY) }
    var endIndex: Index { Index(x: maxX, y: maxY) }
    var lastValidIndex: Index { Index(x: maxX - 1, y: maxY - 1) }
    
    var lastValidElement: Element { lastValidIndex }
    
    
    func index(after i: Index) -> Index {
        if i.y > lastValidIndex.y {
            return endIndex
        }
        else if i.x >= lastValidIndex.x {
            if i.y >= lastValidIndex.y {
                return endIndex
            }
            else {
                return Index(x: startIndex.x, y: i.y.advanced(by: 1))
            }
        }
        else {
            return Index(x: i.x.advanced(by: 1), y: i.y)
        }
    }
    
    
    subscript(position: Index) -> Element {
        if position.x >= maxX
            || position.y >= maxY {
            return lastValidElement
        }
        else {
            return position
        }
    }
}



public extension Collection2D where Element == Index {
    func map2D<ElementOfResult>(_ transformer: (Element) throws -> ElementOfResult) rethrows -> [[ElementOfResult]] {
        let startIndex = self.startIndex
        let lastValidIndex = self.lastValidIndex
        
        return try (startIndex.y ... lastValidIndex.y).map { y in
            try (startIndex.x ... lastValidIndex.x).map { x in
                try transformer(.init(x: x, y: y))
            }
        }
    }
}



// MARK: - Conforming `BinaryIntegerSize` to this

extension BinaryIntegerSize: Sequence
    where
        Length: BinaryInteger,
        Length.Stride: SignedInteger
{
    public typealias Iterator = IndexingIterator<Self>
}



extension BinaryIntegerSize: Collection
    where
        Length: BinaryInteger,
        Length.Stride: SignedInteger
{
    // Empty on-purpose; All witnesses synthesized
}



extension BinaryIntegerSize: Collection2D
    where
        Length: BinaryInteger,
        Length.Stride: SignedInteger
{
    public typealias Index = Collection2DIndex<Length>
    public typealias Element = Index
}



// MARK: - Conforming `BinaryIntegerRectangle` to this

extension BinaryIntegerRectangle: Sequence
    where
        Length: BinaryInteger,
        Length.Stride: SignedInteger
{
    public typealias Iterator = IndexingIterator<Self>
}



extension BinaryIntegerRectangle: Collection
    where
        Length: BinaryInteger,
        Length.Stride: SignedInteger
{
    // Empty on-purpose; All witnesses synthesized
}



extension BinaryIntegerRectangle: Collection2D
    where
        Length: BinaryInteger,
        Length.Stride: SignedInteger
{
    public typealias Index = Collection2DIndex<Length>
    public typealias Element = Index
}
